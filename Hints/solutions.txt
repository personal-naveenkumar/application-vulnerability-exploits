1. Passed the given string from program as argument. strcmp returns true thus giving shell access
2. Gave the strcmp's 2nd arugment string with 2 random characters prefixed as command line argument, using -a flag for exec command while running
3. Similar to 2nd, used the password given in code as the command line argument
4. Passed the password corresponding to checksum_1 as argument to command line. md5sum of a string is constant
5. Using an online md5sum cracker website, found a string whose md5sum mathces string given in code.
6. Found a string whose hash begins with null character. reference: https://stackoverflow.com/a/3180404/6038386
7. Created a program that produces the files "/tmp/md5sum_result_uid_randnum". This execyable is ran in almost same time as main to mathc the random numbers. 
8. Created a symbolic soft link in user home directory. That soft link will point to flag file in root directory.
9. Same as 8th as here also we can exploit the same symbolic soft link.
10. Set BASE environemnt variable to point to user home directory and utilised soft link created from previous problem
11. Similar to 10th
12. Similar to 10th
13. Created flag file in user directory, exploited sleep in code, deleted flag file on parallel shell and created a new soft link
14. Passed /flag as argument. tidy command prints html file which contains flag
15. Passing double quote with argument doesn't make any difference. Did same way as 14
16. Similar to above. Its checking if arg1 contains " but when we pass using "" it just passes inside string as single arg to commmand line
17. Similar to above. Functionality of execlp() - it just takes executable file name as arg1 followed by list of arguments passed to new process image
18. Wrote our own tidy.c and made its executable; run ./main /flag in /challenge directory and run "cat /home/hacker/ans.txt"; get flag from ans.txt
19. Uses concept of command line injection. injecting "/bin/sh" using command line allows us to gain shell access to read flag
20. Similar to 19
21. Give cat command as part of some executable file command (works because suid is set for given file)=> ./main "random && cat /flag"
22. Used scp to get file to local. Decompiled using Ghidra. Concept is same as 22.
23. Similar to 21
24. We need command such that it handles \"\" given in input file already=> ./main "hacker\" -exec cat /flag {} +\""
25. Used {} + option of exec command => ./main "hacker -exec cat /flag {} +". O using {} +, given command works for all found files/dirs 
26. Create a new file soft link that doesn't contain name flag=> /challenge/main "data\" -exec cat {} \;\""
27. Used decompiler to analyse; ./main 0xd 0x401177 => d is the offset of return address from stack top and 401177 is the address of method giving shell access
28. ./main 0x9 0x13371337 => first argument is offset and second is static value of flag being checked in code
29. ./main 00000000004034a0 0x13371337 => use objdump -t main to see address of global variable flag and then pass that first argument. second arg is static value being comapred against flag
30. As per last class slide, created eggcode.c (refernce: https://www.tenouk.com/Bufferoverflowc/bufferoverflowvulexploitdemo32.html) and then ran it to set EGG env variable, passed offset 11 and address of EGG as inputs.
31. Uses buffer overflow concept. Passing given password twice without space works.
32. Uses buffer overflow for global variables involved. first 32 bytes are all 2s and last 32 bytes are its hash and middle 32 bytes are random
33. Its simlar to level 6. strcmp only compares strings till it encounters null. Our code is setting 32nd index as null 
34. Created custom shell file which tells flag value and overflowed given 256 sized buffer, passed our shell program as filename to be run
35. Uses buffer overflow concept. Passes some very long string as argument.
36. Similar to 33, but uses mem compare. first 32 bytes in arg are a string followed by h (neglected in code) and then next bytes are output of the given string
37. Similar to 34
40. Made a new file containing "/bin/sh" and passed this file apth in argument so that we get shell acess
41. ./main {a513LongString} {string in code} 
42. We need to find find a string whose has is ending with 76 (its last 2 byts of memory location of shell function). Did brute force for that.
